# Intuition
<!-- Describe your first thoughts on how to solve this problem. -->
We need to implement a function that enables calling the `groupBy` method on any array, taking a callback function `fn`, and returning a grouped version of the array based on the keys generated by the callback.

# Approach
<!-- Describe your approach to solving the problem. -->
1. These are comment delimiters for a multi-line comment to help explain and document code while preventing ignored text from executing. These comments are commonly used in formal documentation for better code understanding.

    ```
    /**
    * Multi-line comment
    */
    ```

2. This is a special type of comment called a JSDoc comment that explains that the function should take a parameter named `fn`, which is expected to be a `Function`.

    ```
    @param {Function} fn
    ```

3. This is a special type of comment called a JSDoc comment that explains what the code should return, which, in this case, is an `Object`. It helps developers and tools like code editors and documentation generators know what the function is supposed to produce.

    ```
    @return {Object}
    ```

4. This is how we define a function that extends the functionality of arrays by adding a `groupBy` method, which takes a callback function `fn`.

    ```
    Array.prototype.groupBy = function(fn) {
        // code to be executed
    };
    ```

5. This uses the `reduce` function to iterate over the array, accumulating a result object and processing each array element.

    ```
    return this.reduce((res, arr) => {
        // code to be executed
    }, {})
    ```

6. This is how we can apply the provided callback function `fn` to the current array element to determine the grouping key.

    ```
    const key = fn(arr)
    ```

7. This checks if the `key` exists in the result object named `res` and initializes it as an empty array if there is no key.

    ```
    if (!res[key]) {res[key] = []}
    ```

8. This uses `push` function to push the current array element to the array corresponding to its key in the result object.

    ```
    res[key].push(arr)
    ```

9. This returns the updated result object named `res` after processing all array elements.

    ```
    return res
    ```

# Complexity
- Time complexity: $O(n)$
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
`n` is the length of the input array. This is because the function uses the `reduce` method, which iterates through each element of the array once.

- Space complexity: $O(n)$
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
`n` is the number of unique keys returned by the `fn` function. This is because the result object stores arrays for each key, and the total number of arrays is proportional to the length of the input array.

# Code
```
/**
 * @param {Function} fn
 * @return {Object}
 */
Array.prototype.groupBy = function(fn) {
    return this.reduce((res, arr) => {
        const key = fn(arr)
        if (!res[key]) {res[key] = []}
        res[key].push(arr)
        return res
    }, {})
};
```
